
def generate_unique_pairs(strings):
    pairs = []
    n = len(strings)

    for i in range(n):
        for j in range(n):
            if i == j: continue
            pairs.append((strings[i], strings[j]))

    return pairs

def generate_function(pair):
    (f, t) = pair
    return f"static void conversion_candidate(const {f}* p_from, {t}* p_to) {{ *p_to = {t}(*p_from); }}"

def generate_all_functions(list):
    re = ""
    for pair in list:
        line = generate_function(pair)
        re += (" " * INDENT) + line + "\n"
    return re

TYPE_LIST = ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t" , "float", "double"]
INDENT = 8
HEADER_TEMPLATE = f'''
// This file is automatically generated

#ifndef MICROJIT_PRIMITIVE_CONVERSION_MAP_H
#define MICROJIT_PRIMITIVE_CONVERSION_MAP_H

#include <cstdint>

namespace microjit {{
    // The actual conversion won't be done here as
    // primitive type conversion should always be done inline, for performance reason.
    // These functions only act as keys for the actual conversion map,
    // which will be implemented by the compilers independently
    // Update: apparently converting from integer to floating point is too much of a hassle, so no more inlining for them
    class PrimitiveConversionHelper {{
    public:
{generate_all_functions(generate_unique_pairs(TYPE_LIST))}
        template<typename To, typename From>
        static void convert(void (**f)(const From*, To*)){{
            *f = conversion_candidate;
        }}
    }};
}}

#endif //MICROJIT_PRIMITIVE_CONVERSION_MAP_H
'''

TARGET_FILE = "primitive_conversion_map.gen.h"

import sys
import os

(dirname, filename) = os.path.split(sys.argv[0])

full_target_path = os.path.join(dirname, TARGET_FILE)

with open(full_target_path, "wt") as f:
    f.write(HEADER_TEMPLATE)

# print(f"Generated file written to {full_target_path}")
